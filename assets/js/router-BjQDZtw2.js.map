{"version":3,"file":"router-BjQDZtw2.js","sources":["../../../../node_modules/wouter/esm/use-browser-location.js","../../../../node_modules/wouter/esm/index.js"],"sourcesContent":["import { useSyncExternalStore } from './react-deps.js';\n\n/**\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\n */\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nconst eventHashchange = \"hashchange\";\nconst events = [\n  eventPopstate,\n  eventPushState,\n  eventReplaceState,\n  eventHashchange,\n];\n\nconst subscribeToLocationUpdates = (callback) => {\n  for (const event of events) {\n    addEventListener(event, callback);\n  }\n  return () => {\n    for (const event of events) {\n      removeEventListener(event, callback);\n    }\n  };\n};\n\nconst useLocationProperty = (fn, ssrFn) =>\n  useSyncExternalStore(subscribeToLocationUpdates, fn, ssrFn);\n\nconst currentSearch = () => location.search;\n\nconst useSearch = ({ ssrSearch = \"\" } = {}) =>\n  useLocationProperty(currentSearch, () => ssrSearch);\n\nconst currentPathname = () => location.pathname;\n\nconst usePathname = ({ ssrPath } = {}) =>\n  useLocationProperty(\n    currentPathname,\n    ssrPath ? () => ssrPath : currentPathname\n  );\n\nconst currentHistoryState = () => history.state;\nconst useHistoryState = () =>\n  useLocationProperty(currentHistoryState, () => null);\n\nconst navigate = (to, { replace = false, state = null } = {}) =>\n  history[replace ? eventReplaceState : eventPushState](state, \"\", to);\n\n// the 2nd argument of the `useBrowserLocation` return value is a function\n// that allows to perform a navigation.\nconst useBrowserLocation = (opts = {}) => [usePathname(opts), navigate];\n\nconst patchKey = Symbol.for(\"wouter_v3\");\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\nif (typeof history !== \"undefined\" && typeof window[patchKey] === \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n    // TODO: we should be using unstable_batchedUpdates to avoid multiple re-renders,\n    // however that will require an additional peer dependency on react-dom.\n    // See: https://github.com/reactwg/react-18/discussions/86#discussioncomment-1567149\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n\n      dispatchEvent(event);\n      return result;\n    };\n  }\n\n  // patch history object only once\n  // See: https://github.com/molefrog/wouter/issues/167\n  Object.defineProperty(window, patchKey, { value: true });\n}\n\nexport { navigate, useBrowserLocation, useHistoryState, useLocationProperty, usePathname, useSearch };\n","import { parse } from 'regexparam';\nimport { useBrowserLocation, useSearch as useSearch$1 } from './use-browser-location.js';\nimport { createContext, forwardRef, useEvent, isValidElement, cloneElement, createElement, useContext, useRef, useMemo, useIsomorphicLayoutEffect, Fragment } from './react-deps.js';\n\n/*\n * Transforms `path` into its relative `base` version\n * If base isn't part of the path provided returns absolute path e.g. `~/app`\n */\nconst _relativePath = (base, path) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n\n/**\n * When basepath is `undefined` or '/' it is ignored (we assume it's empty string)\n */\nconst baseDefaults = (base = \"\") => (base === \"/\" ? \"\" : base);\n\nconst absolutePath = (to, base) =>\n  to[0] === \"~\" ? to.slice(1) : baseDefaults(base) + to;\n\nconst relativePath = (base = \"\", path) =>\n  _relativePath(unescape(baseDefaults(base)), unescape(path));\n\n/*\n * Removes leading question mark\n */\nconst stripQm = (str) => (str[0] === \"?\" ? str.slice(1) : str);\n\n/*\n * decodes escape sequences such as %20\n */\nconst unescape = (str) => {\n  try {\n    return decodeURI(str);\n  } catch (_e) {\n    // fail-safe mode: if string can't be decoded do nothing\n    return str;\n  }\n};\n\nconst sanitizeSearch = (search) => unescape(stripQm(search));\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nconst defaultRouter = {\n  hook: useBrowserLocation,\n  searchHook: useSearch$1,\n  parser: parse,\n  base: \"\",\n  // this option is used to override the current location during SSR\n  ssrPath: undefined,\n  ssrSearch: undefined,\n  // optional context to track render state during SSR\n  ssrContext: undefined,\n  // customizes how `href` props are transformed for <Link />\n  hrefs: (x) => x,\n};\n\nconst RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nconst useRouter = () => useContext(RouterCtx);\n\n/**\n * Parameters context. Used by `useParams()` to get the\n * matched params from the innermost `Route` component.\n */\n\nconst Params0 = {},\n  ParamsCtx = createContext(Params0);\n\nconst useParams = () => useContext(ParamsCtx);\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\n\nconst useLocationFromRouter = (router) => {\n  const [location, navigate] = router.hook(router);\n\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  // (This is achieved via `useEvent`.)\n  return [\n    relativePath(router.base, location),\n    useEvent((to, navOpts) => navigate(absolutePath(to, router.base), navOpts)),\n  ];\n};\n\nconst useLocation = () => useLocationFromRouter(useRouter());\n\nconst useSearch = () => {\n  const router = useRouter();\n  return sanitizeSearch(router.searchHook(router));\n};\n\nconst matchRoute = (parser, route, path, loose) => {\n  // if the input is a regexp, skip parsing\n  const { pattern, keys } =\n    route instanceof RegExp\n      ? { keys: false, pattern: route }\n      : parser(route || \"*\", loose);\n\n  // array destructuring loses keys, so this is done in two steps\n  const result = pattern.exec(path) || [];\n\n  // when parser is in \"loose\" mode, `$base` is equal to the\n  // first part of the route that matches the pattern\n  // (e.g. for pattern `/a/:b` and path `/a/1/2/3` the `$base` is `a/1`)\n  // we use this for route nesting\n  const [$base, ...matches] = result;\n\n  return $base !== undefined\n    ? [\n        true,\n\n        (() => {\n          // for regex paths, `keys` will always be false\n\n          // an object with parameters matched, e.g. { foo: \"bar\" } for \"/:foo\"\n          // we \"zip\" two arrays here to construct the object\n          // [\"foo\"], [\"bar\"] â†’ { foo: \"bar\" }\n          const groups =\n            keys !== false\n              ? Object.fromEntries(keys.map((key, i) => [key, matches[i]]))\n              : result.groups;\n\n          // convert the array to an instance of object\n          // this makes it easier to integrate with the existing param implementation\n          let obj = { ...matches };\n\n          // merge named capture groups with matches array\n          groups && Object.assign(obj, groups);\n\n          return obj;\n        })(),\n\n        // the third value if only present when parser is in \"loose\" mode,\n        // so that we can extract the base path for nested routes\n        ...(loose ? [$base] : []),\n      ]\n    : [false, null];\n};\n\nconst useRoute = (pattern) =>\n  matchRoute(useRouter().parser, pattern, useLocation()[0]);\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nconst Router = ({ children, ...props }) => {\n  // the router we will inherit from - it is the closest router in the tree,\n  // unless the custom `hook` is provided (in that case it's the default one)\n  const parent_ = useRouter();\n  const parent = props.hook ? defaultRouter : parent_;\n\n  // holds to the context value: the router object\n  let value = parent;\n\n  // when `ssrPath` contains a `?` character, we can extract the search from it\n  const [path, search] = props.ssrPath?.split(\"?\") ?? [];\n  if (search) (props.ssrSearch = search), (props.ssrPath = path);\n\n  // hooks can define their own `href` formatter (e.g. for hash location)\n  props.hrefs = props.hrefs ?? props.hook?.hrefs;\n\n  // what is happening below: to avoid unnecessary rerenders in child components,\n  // we ensure that the router object reference is stable, unless there are any\n  // changes that require reload (e.g. `base` prop changes -> all components that\n  // get the router from the context should rerender, even if the component is memoized).\n  // the expected behaviour is:\n  //\n  //   1) when the resulted router is no different from the parent, use parent\n  //   2) if the custom `hook` prop is provided, we always inherit from the\n  //      default router instead. this resets all previously overridden options.\n  //   3) when the router is customized here, it should stay stable between renders\n  let ref = useRef({}),\n    prev = ref.current,\n    next = prev;\n\n  for (let k in parent) {\n    const option =\n      k === \"base\"\n        ? /* base is special case, it is appended to the parent's base */\n          parent[k] + (props[k] || \"\")\n        : props[k] || parent[k];\n\n    if (prev === next && option !== next[k]) {\n      ref.current = next = { ...next };\n    }\n\n    next[k] = option;\n\n    // the new router is no different from the parent or from the memoized value, use parent\n    if (option !== parent[k] || option !== value[k]) value = next;\n  }\n\n  return createElement(RouterCtx.Provider, { value, children });\n};\n\nconst h_route = ({ children, component }, params) => {\n  // React-Router style `component` prop\n  if (component) return createElement(component, { params });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\n\n// Cache params object between renders if values are shallow equal\nconst useCachedParams = (value) => {\n  let prev = useRef(Params0);\n  const curr = prev.current;\n  return (prev.current =\n    // Update cache if number of params changed or any value changed\n    Object.keys(value).length !== Object.keys(curr).length ||\n    Object.entries(value).some(([k, v]) => v !== curr[k])\n      ? value // Return new value if there are changes\n      : curr); // Return cached value if nothing changed\n};\n\nfunction useSearchParams() {\n  const [location, navigate] = useLocation();\n\n  const search = useSearch();\n  const searchParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  // cached value before next render, so you can call setSearchParams multiple times\n  let tempSearchParams = searchParams;\n\n  const setSearchParams = useEvent((nextInit, options) => {\n    tempSearchParams = new URLSearchParams(\n      typeof nextInit === \"function\" ? nextInit(tempSearchParams) : nextInit\n    );\n    navigate(location + \"?\" + tempSearchParams, options);\n  });\n\n  return [searchParams, setSearchParams];\n}\n\nconst Route = ({ path, nest, match, ...renderProps }) => {\n  const router = useRouter();\n  const [location] = useLocationFromRouter(router);\n\n  const [matches, routeParams, base] =\n    // `match` is a special prop to give up control to the parent,\n    // it is used by the `Switch` to avoid double matching\n    match ?? matchRoute(router.parser, path, location, nest);\n\n  // when `routeParams` is `null` (there was no match), the argument\n  // below becomes {...null} = {}, see the Object Spread specs\n  // https://tc39.es/proposal-object-rest-spread/#AbstractOperations-CopyDataProperties\n  const params = useCachedParams({ ...useParams(), ...routeParams });\n\n  if (!matches) return null;\n\n  const children = base\n    ? createElement(Router, { base }, h_route(renderProps, params))\n    : h_route(renderProps, params);\n\n  return createElement(ParamsCtx.Provider, { value: params, children });\n};\n\nconst Link = forwardRef((props, ref) => {\n  const router = useRouter();\n  const [currentPath, navigate] = useLocationFromRouter(router);\n\n  const {\n    to = \"\",\n    href: targetPath = to,\n    onClick: _onClick,\n    asChild,\n    children,\n    className: cls,\n    /* eslint-disable no-unused-vars */\n    replace /* ignore nav props */,\n    state /* ignore nav props */,\n    /* eslint-enable no-unused-vars */\n\n    ...restProps\n  } = props;\n\n  const onClick = useEvent((event) => {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (\n      event.ctrlKey ||\n      event.metaKey ||\n      event.altKey ||\n      event.shiftKey ||\n      event.button !== 0\n    )\n      return;\n\n    _onClick?.(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(targetPath, props);\n    }\n  });\n\n  // handle nested routers and absolute paths\n  const href = router.hrefs(\n    targetPath[0] === \"~\" ? targetPath.slice(1) : router.base + targetPath,\n    router // pass router as a second argument for convinience\n  );\n\n  return asChild && isValidElement(children)\n    ? cloneElement(children, { onClick, href })\n    : createElement(\"a\", {\n        ...restProps,\n        onClick,\n        href,\n        // `className` can be a function to apply the class if this link is active\n        className: cls?.call ? cls(currentPath === targetPath) : cls,\n        children,\n        ref,\n      });\n});\n\nconst flattenChildren = (children) =>\n  Array.isArray(children)\n    ? children.flatMap((c) =>\n        flattenChildren(c && c.type === Fragment ? c.props.children : c)\n      )\n    : [children];\n\nconst Switch = ({ children, location }) => {\n  const router = useRouter();\n  const [originalLocation] = useLocationFromRouter(router);\n\n  for (const element of flattenChildren(children)) {\n    let match = 0;\n\n    if (\n      isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = matchRoute(\n        router.parser,\n        element.props.path,\n        location || originalLocation,\n        element.props.nest\n      ))[0]\n    )\n      return cloneElement(element, { match });\n  }\n\n  return null;\n};\n\nconst Redirect = (props) => {\n  const { to, href = to } = props;\n  const router = useRouter();\n  const [, navigate] = useLocationFromRouter(router);\n  const redirect = useEvent(() => navigate(to || href, props));\n  const { ssrContext } = router;\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(() => {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  if (ssrContext) {\n    ssrContext.redirectTo = to;\n  }\n\n  return null;\n};\n\nexport { Link, Redirect, Route, Router, Switch, matchRoute, useLocation, useParams, useRoute, useRouter, useSearch, useSearchParams };\n"],"names":["eventPushState","eventReplaceState","events","subscribeToLocationUpdates","callback","event","addEventListener","removeEventListener","useLocationProperty","fn","ssrFn","useSyncExternalStore","currentSearch","location","search","currentPathname","pathname","usePathname","ssrPath","navigate","to","replace","state","history","patchKey","Symbol","for","window","type","original","result","apply","this","arguments","Event","dispatchEvent","Object","defineProperty","value","baseDefaults","base","relativePath","path","toLowerCase","indexOf","slice","length","_relativePath","unescape","str","decodeURI","_e","defaultRouter","hook","opts","searchHook","ssrSearch","parser","parse","undefined","ssrContext","hrefs","x","RouterCtx","createContext","useRouter","useContext","Params0","ParamsCtx","useLocationFromRouter","router","useEvent","navOpts","absolutePath","useLocation","matchRoute","route","loose","pattern","keys","RegExp","exec","$base","matches","groups","fromEntries","map","key","i","obj","assign","useRoute","Router","children","props","parent_","parent","split","ref","useRef","prev","current","next","k","option","createElement","Provider","h_route","component","params","Route","nest","match","renderProps","routeParams","curr","entries","some","v","useCachedParams","Link","forwardRef","currentPath","href","targetPath","onClick","_onClick","asChild","className","cls","restProps","ctrlKey","metaKey","altKey","shiftKey","button","defaultPrevented","preventDefault","isValidElement","cloneElement","call","flattenChildren","Array","isArray","flatMap","c","Fragment","Switch","originalLocation","element","Redirect","redirect","useIsomorphicLayoutEffect","redirectTo"],"mappings":"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","x_google_ignoreList":[0,1]}